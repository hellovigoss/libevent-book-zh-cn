include::license.txt[]

:language: C

== 设置Libevent



Libevent有一些全局设置项可供整个
进程共享。  这些影响整个类库。

你 *必须* 在进行Libevent类库中其他部分的调用前进行设置调整
。  否则，Libevent库最终
状态会不一致。

== Libevent中的日志记录

Libevent可以记录内部错误与警告。  同样当编译时候打开logging支持后
便可以记录调试信息。  默认情况下，这些
信息会被输出至stderr。  你可以通过提供自己的日志函数来
重写这些行为。

.Interface
[code,C]
--------
#define EVENT_LOG_DEBUG 0
#define EVENT_LOG_MSG   1
#define EVENT_LOG_WARN  2
#define EVENT_LOG_ERR   3

/* Deprecated; see note at the end of this section */
#define _EVENT_LOG_DEBUG EVENT_LOG_DEBUG
#define _EVENT_LOG_MSG   EVENT_LOG_MSG
#define _EVENT_LOG_WARN  EVENT_LOG_WARN
#define _EVENT_LOG_ERR   EVENT_LOG_ERR

typedef void (*event_log_cb)(int severity, const char *msg);

void event_set_log_callback(event_log_cb cb);
--------

要覆盖Libevent的日志行为，可以提供你自己的
匹配event_log_cb事件的函数，并且将其作为参数传入
event_set_log_callback()函数。  当Libevent记录一条消息时，它
将把它传递给您提供的函数。  你可以通过传送再次调用
event_set_log_callback()函数并且设置NULL参数来触发Libevent的
默认日志行为。

.Examples
[code,C]
--------
#include <event2/event.h>
#include <stdio.h>

static void discard_cb(int severity, const char *msg)
{
    /* This callback does nothing. */
}

static FILE *logfile = NULL;
static void write_to_file_cb(int severity, const char *msg)
{
    const char *s;
    if (!logfile)
        return;
    switch (severity) {
        case _EVENT_LOG_DEBUG: s = "debug"; break;
        case _EVENT_LOG_MSG:   s = "msg";   break;
        case _EVENT_LOG_WARN:  s = "warn";  break;
        case _EVENT_LOG_ERR:   s = "error"; break;
        default:               s = "?";     break; /* never reached */
    }
    fprintf(logfile, "[%s] %s\n", s, msg);
}

/* Turn off all logging from Libevent. */
void suppress_logging(void)
{
    event_set_log_callback(discard_cb);
}

/* Redirect all Libevent log messages to the C stdio file 'f'. */
void set_logfile(FILE *f)
{
    logfile = f;
    event_set_log_callback(write_to_file_cb);
}
--------

注意
在用户提供的event_log_cb回调函数中代理Libevent方法不安全！比如：一旦你试图
在日志回调方法中通过网络套接字使用bufferevents来发送告警信息，就有可能搞出一些奇怪的bug。
在将来的Libevent版本中这个限制可能在某些函数中移除。

通常，调试日志不会默认启用，也不会发送到日志回调。可以通过编译参数手动打开此功能。

.Interface
[code,C]
-----
#define EVENT_DBG_NONE 0
#define EVENT_DBG_ALL 0xffffffffu

void event_enable_debug_logging(ev_uint32_t which);
-----

调试日志是非常详细，在大多数情况下不需要启用。通过调用event_enable_debug_logging()并且设置
EVENT_DBG_NONE设置默认行为；设置EVENT_DBG_ALL则会启用所有支持的调试日志。
更多细分力度的日志level也会在将来的版本被支持。

以上方法在<event2/event.h>中申明。首次被创建于Libevent 1.0c，除了event_enable_debug_logging()，它首次出现于Libevent 2.1.1-alpha。

.COMPATIBILITY NOTE
Libevent 2.0.19-stable之前，EVENT_LOG_*相关的宏定义都以下划线开头：_EVENT_LOG_DEBUG，_EVENT_LOG_MSG，_EVENT_LOG_WARN，以及_EVENT_LOG_ERR。以上老的命名都已经被废弃，除非是考虑向前Libevent 2.0.18-stable与以前版本兼容。
在将来的Libevent版本中也会被移除。

处理致命错误

Libevent一旦出现无法恢复的内部错误（比如数据结构损坏），它就会通过exit()或者abort()退出当前进程。
这些错误通常意味着你的代码或者Libevent类库有bug。

你也可以通过提供一个Libevent在退出过程中调用的方法来优雅处理致命错误。

.Interface
[code,C]
--------
typedef void (*event_fatal_cb)(int err);
void event_set_fatal_callback(event_fatal_cb cb);
--------

首先定义一个当Libevent出现致命错误时候调用的方法，然后传入event_set_fatal_callback()。
之后一旦Libevent出现致命错误，就会调用该方法。


你定义的函数 *不应该* 再回头操作Libevent；如果尝试这样做，Libevent可能会直接退出以避免崩溃。
一旦自定义错误处理方法被调用，就不应该调用其他任何的Libevent方法。

以上方法定义在<event2/event.h>头中。首次被定义于Libevent 2.0.3-alpha。


== 内存管理

Libevent使用C默认内存管理库进行内存分配。假如你有更高效的内存管理方案，或者需要一个内存泄漏的仪表台。
那么你也可以提供一个自己的malloc、realloc和free实现来替代默认的内存管理行文。

.Interface
[code,C]
--------
void event_set_mem_functions(void *(*malloc_fn)(size_t sz),
                             void *(*realloc_fn)(void *ptr, size_t sz),
                             void (*free_fn)(void *ptr));
--------

下面是一个简单的示例，它将Libevent的分配函数替换为计算所分配字节总数的变量。实际上，当Libevent在多个线程中运行时，可能需要在这里添加锁定以防止错误。

.Example
[code,C]
--------
#include <event2/event.h>
#include <sys/types.h>
#include <stdlib.h>

/* This union's purpose is to be as big as the largest of all the
 * types it contains. */
union alignment {
    size_t sz;
    void *ptr;
    double dbl;
};
/* We need to make sure that everything we return is on the right
   alignment to hold anything, including a double. */
#define ALIGNMENT sizeof(union alignment)

/* We need to do this cast-to-char* trick on our pointers to adjust
   them; doing arithmetic on a void* is not standard. */
#define OUTPTR(ptr) (((char*)ptr)+ALIGNMENT)
#define INPTR(ptr) (((char*)ptr)-ALIGNMENT)

static size_t total_allocated = 0;
static void *replacement_malloc(size_t sz)
{
    void *chunk = malloc(sz + ALIGNMENT);
    if (!chunk) return chunk;
    total_allocated += sz;
    *(size_t*)chunk = sz;
    return OUTPTR(chunk);
}
static void *replacement_realloc(void *ptr, size_t sz)
{
    size_t old_size = 0;
    if (ptr) {
        ptr = INPTR(ptr);
        old_size = *(size_t*)ptr;
    }
    ptr = realloc(ptr, sz + ALIGNMENT);
    if (!ptr)
        return NULL;
    *(size_t*)ptr = sz;
    total_allocated = total_allocated - old_size + sz;
    return OUTPTR(ptr);
}
static void replacement_free(void *ptr)
{
    ptr = INPTR(ptr);
    total_allocated -= *(size_t*)ptr;
    free(ptr);
}
void start_counting_bytes(void)
{
    event_set_mem_functions(replacement_malloc,
                            replacement_realloc,
                            replacement_free);
}
--------

.NOTES
- 替换内存管理函数作用于所有Libevent的allocate，resize和free功能调用。因此，
需要保证在其他Libevent方法调用之前完成替换。否则，Libevent会使用您提供的方法来销毁C标准库
申请的内存。
- 你的malloc与realloc方法需要于C标准库以相同对于内存块的操作需要相同的对齐方案。
- 你的realloc方法需要正确处理realloc(NULL, dz)（相当于malloc(sz)）。
- 你的realloc方法需要正确处理realloc(ptr, 0)（相当于free(ptr)）。
- 你的free方法不需要处理free(NULL)。
- 你的malloc方法不需要处理malloc(0)。
- 在多线程的Libevent环境中替换内存管理的方法需要线程安全。
- Libevent将会使用你提供的这些方法进行内存申请。意味着，一旦你需要释放Libevent提供的方法申请
的内存，你需要替换malloc和realloc方法，然后你才可以通过替换的free方法释放。

event_set_mem_functions()方法定义在<event2/event.h>中。
首次声明于Libevent 2.0.1-alpha。

Libevent可以在event_set_mem_functions()禁用的情况下编译。这样程序就不必编译或者链接相关方法。
在Libevent 2.0.2-alpha版本之后，你可以通过检查EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED宏定义来判断是否
存在此设定。

锁与多线程

如你所知，在多线程的程序中，同时对同一份数据进行操作是不安全的。

Libevent结构体在多线程场景下主要分三种工作模式。

- 部分结构天然是单线成：它不应该跨线程使用。
- 部分结构可以选择被锁：当你需要多线程使用时可以选择通过Libevent进行上锁。
- 部分结构默认会加锁：如果Libevent在支持锁的模式下运行，这些数据结构就是线程安全的。

在Libevent上锁，需要告知Libevent具体上锁函数。
需要在跨线程共享数据钱进行以上操作。

如果使用了pthread类库，或者Windows niative线程代码。Libevent中内置了一些函数可以天然适配。

.Interface
[code,C]
--------
#ifdef WIN32
int evthread_use_windows_threads(void);
#define EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED
#endif
#ifdef _EVENT_HAVE_PTHREADS
int evthread_use_pthreads(void);
#define EVTHREAD_USE_PTHREADS_IMPLEMENTED
#endif
--------

以上函数成功返回0，失败返回-1。

如果需要使用别的线程库，需要做一些额外工作。
你需要定义这些函数供你的类库实现：


- Locks
  - locking
  - unlocking
  - lock allocation
  - lock destruction
  - Conditions
  - condition variable creation
  - condition variable destruction
  - waiting on a condition variable
  - signaling/broadcasting to a condition variable
- Threads
  - thread ID detection

然后通过evthread_set_lock_callbacks与evthread_set_id_callback接口告知Libevent以上函数定义。

.Interface
[code,C]
--------
#define EVTHREAD_WRITE	0x04
#define EVTHREAD_READ	0x08
#define EVTHREAD_TRY	0x10

#define EVTHREAD_LOCKTYPE_RECURSIVE 1
#define EVTHREAD_LOCKTYPE_READWRITE 2

#define EVTHREAD_LOCK_API_VERSION 1

struct evthread_lock_callbacks {
       int lock_api_version;
       unsigned supported_locktypes;
       void *(*alloc)(unsigned locktype);
       void (*free)(void *lock, unsigned locktype);
       int (*lock)(unsigned mode, void *lock);
       int (*unlock)(unsigned mode, void *lock);
};

int evthread_set_lock_callbacks(const struct evthread_lock_callbacks *);

void evthread_set_id_callback(unsigned long (*id_fn)(void));

struct evthread_condition_callbacks {
        int condition_api_version;
        void *(*alloc_condition)(unsigned condtype);
        void (*free_condition)(void *cond);
        int (*signal_condition)(void *cond, int broadcast);
        int (*wait_condition)(void *cond, void *lock,
            const struct timeval *timeout);
};

int evthread_set_condition_callbacks(
        const struct evthread_condition_callbacks *);
--------

evthread_lock_callbacks结构描述上锁回调以及他们的具体能力。
在以上版本中，lock_api_version字段必须设置为EVTHREAD_LOCK_API_VERSION。
supported_locktypes字段必须设置为EVTHREAD_LOCKTYPE_*常量定义的为掩码以描述你所支持的锁类型。
（2.0.4-alpha中, 需要强制设置为EVTHREAD_LOCK_RECURSIVE，并且暂不支持EVTHREAD_LOCK_READWRITE。）
alloc方法必须返回一个特殊类型的锁。free方法必须释放锁占用的相应资源。lock方法必须尝试获取一个特殊模式下的锁，
它成功返回0，否则返回非0.unlock方法必须释放对应锁，成功返回0，失败返回非0。


相关支持的锁类型有：

0::
        常规锁，不可重复上锁。

EVTHREAD_LOCKTYPE_RECURSIVE::
        当线程对资源上锁后，本线程可以继续获取锁，其他线程需要等本线程释放。

EVTHREAD_LOCKTYPE_READWRITE::
        多线程仅允许读操作获取锁，写操作仅允许一个线程持有。

锁模式有以下：

EVTHREAD_READ::
        针对读写锁：申请或者释放读操作锁。

EVTHREAD_WRITE::
        针对读写锁：申请或者释放写操作锁。

EVTHREAD_TRY::
        锁操作：该模式只在可以获得锁时候立即上锁，否则不等待。

The id_fn argument must be a function returning an unsigned long
identifying what thread is calling the function.  It must always return
the same number for the same thread, and must not ever return the same
number for two different threads if they are both executing at the same
time.

The evthread_condition_callbacks structure describes callbacks related to
condition variables.  For the version described above, the lock_api_version
field must be set to EVTHREAD_CONDITION_API_VERSION.  The alloc_condition
function must return a pointer to a new condition variable.  It receives 0 as
its argument.  The free_condition function must release storage and resources
held by a condition variable.  The wait_condition function takes three
arguments: a condition allocated by alloc_condition, a lock allocated by the
evthread_lock_callbacks.alloc function you provided, and an optional timeout.
The lock will be held whenever the function is called; the function must
release the lock, and wait until the condition becomes signalled or until the
(optional) timeout has elapsed.  The wait_condition function should return -1
on an error, 0 if the condition is signalled, and 1 on a timeout.  Before it
returns, it should make sure it holds the lock again.  Finally, the
signal_condition function should cause _one_ thread waiting on the condition
to wake up (if its broadcast argument is false) and _all_ threads currently
waiting on the condition to wake up (if its broadcast argument is true).  It
will only be held while holding the lock associated with the condition.

For more information on condition variables, look at the documentation for
pthreads's pthread_cond_* functions, or Windows's CONDITION_VARIABLE
functions.

.Examples

------
For an example of how to use these functions, see evthread_pthread.c and
evthread_win32.c in the Libevent source distribution.
------

The functions in this section are declared in <event2/thread.h>.  Most of
them first
appeared in Libevent 2.0.4-alpha.  Libevent versions from 2.0.1-alpha through
2.0.3-alpha used an older interface to set locking functions.  The
event_use_pthreads() function requires you to link your program against the
event_pthreads library.

The condition-variable functions were new in Libevent 2.0.7-rc; they were
added to solve some otherwise intractable deadlock problems.

Libevent can be built with locking support disabled.  If it is, then
programs built to use the above thread-related functions will not
run.

Debugging lock usage
~~~~~~~~~~~~~~~~~~~~

To help debug lock usage, Libevent has an optional "lock debugging"
feature that wraps its locking calls in order to catch typical lock
errors, including:

- unlocking a lock that we don't actually hold
- re-locking a non-recursive lock

If one of these lock errors occurs, Libevent exits with an assertion failure.

.Interface
[code,C]
-----
void evthread_enable_lock_debugging(void);
#define evthread_enable_lock_debuging() evthread_enable_lock_debugging()
-----

NOTE: This function MUST be called before any locks are created or used.  To
be safe, call it just after you set your threading functions.

This function was new in Libevent 2.0.4-alpha with the misspelled name
"evthread_enable_lock_debuging()."  The spelling was fixed to
evthread_enable_lock_debugging() in 2.1.2-alpha; both names are currently
supported.

Debugging event usage
~~~~~~~~~~~~~~~~~~~~~

There are some common errors in using events that Libevent can detect and
report for you.  They include:

- Treating an uninitialized struct event as though it were initialized.
- Try to reinitialize a pending struct event.

Tracking which events are initialized requires that Libevent use extra memory
and CPU, so you should only enable debug mode when actually debugging your
program. 

.Interface
[code,C]
-----
void event_enable_debug_mode(void);
-----

This function must only be called before any event_base is created.

When using debug mode, you might run out of memory if your program uses a
large number of events created with event_assign() [not event_new()].  This
happens because Libevent has no way of telling when an event created with
event_assign() will no longer be used.  (It can tell that an event_new()
event has become invalid when you call event_free() on it.)  If you want to
avoid running out of memory while debugging, you can explicitly tell Libevent
that such events are no longer to be treated as assigned:

.Interface
[code,C]
-----
void event_debug_unassign(struct event *ev);
-----

Calling event_debug_unassign() has no effect when debugging is not enabled.

.Example
[code,C]
-----
#include <event2/event.h>
#include <event2/event_struct.h>

#include <stdlib.h>

void cb(evutil_socket_t fd, short what, void *ptr)
{
    /* We pass 'NULL' as the callback pointer for the heap allocated
     * event, and we pass the event itself as the callback pointer
     * for the stack-allocated event. */
    struct event *ev = ptr;

    if (ev)
        event_debug_unassign(ev);
}

/* Here's a simple mainloop that waits until fd1 and fd2 are both
 * ready to read. */
void mainloop(evutil_socket_t fd1, evutil_socket_t fd2, int debug_mode)
{
    struct event_base *base;
    struct event event_on_stack, *event_on_heap;

    if (debug_mode)
       event_enable_debug_mode();

    base = event_base_new();

    event_on_heap = event_new(base, fd1, EV_READ, cb, NULL);
    event_assign(&event_on_stack, base, fd2, EV_READ, cb, &event_on_stack);

    event_add(event_on_heap, NULL);
    event_add(&event_on_stack, NULL);

    event_base_dispatch(base);

    event_free(event_on_heap);
    event_base_free(base);
}
-----

Detailed event debugging is a feature which can only be enabled at compile-time using
the CFLAGS environment variable "-DUSE_DEBUG". With this flag enabled, any program compiled 
against Libevent will output a very verbose log detailing low-level activity on the back-end.
These logs include, but not limited to, the following:

- event additions
- event deletions
- platform specific event notification information

This feature cannot be enabled or disabled via an API call so it must only be
used in developer builds. 

These debugging functions were added in Libevent 2.0.4-alpha.


Detecting the version of Libevent
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

New versions of Libevent can add features and remove bugs.  Sometimes
you'll want to detect the Libevent version, so that you can:

- Detect whether the installed version of Libevent is good enough to
  build your program.
- Display the Libevent version for debugging.
- Detect the version of Libevent so that you can warn the user about
  bugs, or work around them.

.Interface
[code,C]
--------
#define LIBEVENT_VERSION_NUMBER 0x02000300
#define LIBEVENT_VERSION "2.0.3-alpha"
const char *event_get_version(void);
ev_uint32_t event_get_version_number(void);
--------

The macros make available the compile-time version of the Libevent
library; the functions return the run-time version.  Note that if you
have dynamically linked your program against Libevent, these versions
may be different.

You can get a Libevent version in two formats: as a string suitable for
displaying to users, or as a 4-byte integer suitable for numerical
comparison.  The integer format uses the high byte for the major version,
the second byte for the minor version, the third byte for the patch version, and
the low byte to indicate release status (0 for release, nonzero for a
development series after a given release).

Thus, the released Libevent 2.0.1-alpha has the version number of [02 00
01 00], or 0x02000100.  A development versions between 2.0.1-alpha and
2.0.2-alpha might have a version number of [02 00 01 08], or 0x02000108.

.Example: Compile-time checks
[code,C]
--------
#include <event2/event.h>

#if !defined(LIBEVENT_VERSION_NUMBER) || LIBEVENT_VERSION_NUMBER < 0x02000100
#error "This version of Libevent is not supported; Get 2.0.1-alpha or later."
#endif

int
make_sandwich(void)
{
        /* Let's suppose that Libevent 6.0.5 introduces a make-me-a
           sandwich function. */
#if LIBEVENT_VERSION_NUMBER >= 0x06000500
        evutil_make_me_a_sandwich();
        return 0;
#else
        return -1;
#endif
}
--------

.Example: Run-time checks
[code,C]
--------
#include <event2/event.h>
#include <string.h>

int
check_for_old_version(void)
{
    const char *v = event_get_version();
    /* This is a dumb way to do it, but it is the only thing that works
       before Libevent 2.0. */
    if (!strncmp(v, "0.", 2) ||
        !strncmp(v, "1.1", 3) ||
        !strncmp(v, "1.2", 3) ||
        !strncmp(v, "1.3", 3)) {

        printf("Your version of Libevent is very old.  If you run into bugs,"
               " consider upgrading.\n");
        return -1;
    } else {
        printf("Running with Libevent version %s\n", v);
        return 0;
    }
}

int
check_version_match(void)
{
    ev_uint32_t v_compile, v_run;
    v_compile = LIBEVENT_VERSION_NUMBER;
    v_run = event_get_version_number();
    if ((v_compile & 0xffff0000) != (v_run & 0xffff0000)) {
        printf("Running with a Libevent version (%s) very different from the "
               "one we were built with (%s).\n", event_get_version(),
               LIBEVENT_VERSION);
        return -1;
    }
    return 0;
}
--------

The macros and functions in this section are defined in
<event2/event.h>.  The event_get_version() function first appeared in
Libevent 1.0c; the others first appeared in Libevent 2.0.1-alpha.


Freeing global Libevent structures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Even when you've freed all the objects that you allocated with Libevent,
there will be a few globally allocated structures left over.  This isn't
usually a problem: once the process exits, they will all get cleaned up
anyway.  But having these structures can confuse some debugging tools into
thinking that Libevent is leaking resources.  If you need to make sure that
Libevent has released all internal library-global data structures, you can
call:

.Interface
[code,C]
--------
void libevent_global_shutdown(void);
--------

This function doesn't free any structures that were returned to you by a
Libevent function.  If you want to free everything before exiting, you'll
need to free all events, event_bases, bufferevents, and so on yourself.

Calling libevent_global_shutdown() will make other Libevent functions behave
unpredictably; don't call it except as the last Libevent function your
program invokes.  One exception is that libevent_global_shutdown() is
idempotent: it is okay to call it even if it has already been called.

This function is declared in <event2/event.h>. It was introduced in Libevent
2.1.1-alpha.

